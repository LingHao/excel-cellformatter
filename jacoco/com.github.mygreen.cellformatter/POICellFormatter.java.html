<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>POICellFormatter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Excel-CellFormatter</a> &gt; <a href="index.source.html" class="el_package">com.github.mygreen.cellformatter</a> &gt; <span class="el_source">POICellFormatter.java</span></div><h1>POICellFormatter.java</h1><pre class="source lang-java linenums">package com.github.mygreen.cellformatter;

import java.util.Locale;

import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellValue;
import org.apache.poi.ss.usermodel.CreationHelper;
import org.apache.poi.ss.usermodel.FormulaError;
import org.apache.poi.ss.usermodel.FormulaEvaluator;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.util.CellRangeAddress;


/**
 * Apache POIのセルの値を文字列として取得するためのクラス。
 * 
 * 
 * &lt;h3 class=&quot;description&quot;&gt;基本的な使い方&lt;/h3&gt; 
 * &lt;p&gt;{@link POICellFormatter}のインスタンスを生成して利用します。&lt;/p&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;結果を単純に文字列で取得したい場合は、{@link #formatAsString(Cell)}を利用します。&lt;/li&gt;
 *   &lt;li&gt;フォーマット対象のセルの値や書式に適用された文字色などを取得したい場合は、
 *       {@link #format(Cell)}の結果である{@link CellFormatResult}から取得します。&lt;/li&gt;
 *   &lt;li&gt;書式「{@literal m/d/yy}」など、実行環境の言語設定によって切り替わるような場合は、
 *       {@link #formatAsString(Cell, Locale)}でロケールを直接指定します。&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * POICellFormatter  cellFormatter = new POICellFormatter ();
 * 
 * Cell cell = // セルの取得
 * String text1 = cellForrmatter.formatAsString(cell);
 * 
 * // ロケールに依存する書式の場合
 * String text2 = cellForrmatter.formatAsString(cell, Locale.US);
 *
 * // 文字色の条件が設定されている場合
 * CellFormatResult result = cellForrmatter.format(cell);
 * String text3 = result.getText(); // フォーマット結果の文字列
 * MSColor textColor = result.getTextColor(); // 書式の文字色
 * &lt;/code&gt;&lt;/pre&gt;
 * 
 * &lt;h3 class=&quot;description&quot;&gt;注意事項&lt;/h3&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;Cellのインスタンスがnullの場合、空（Blank）セルとして扱います。
 *       &lt;br&gt;POIの場合、データの入力がない領域のセルは、nullとなるためです。&lt;/li&gt;
 *   &lt;li&gt;結合されたセルの場合、結合領域を走査し、非空セルがそのセルの値を評価します。
 *       &lt;br&gt;POIの場合、結合されたセルの領域は、基本的に左上のセルに値が設定され、それ以外のセルは空セルとなるためです。&lt;/li&gt;
 *   &lt;li&gt;数式や関数が設定されたセルの場合、それらを評価した結果を返します。
 *       &lt;br&gt;POIが対応していない数式や関数の場合、Excel上では正しく表示されていても、エラーセルの扱いとなります。
 *       &lt;br&gt;使用するPOIのバージョンによって対応する関数も異なります。&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * @see &lt;a href=&quot;http://www.ne.jp/asahi/hishidama/home/tech/apache/poi/cell.html&quot; target=&quot;_blank&quot;&gt;ひしだま's 技術メモページ - Apache POI Cell : Cellの値の取得&lt;/a&gt;
 * @see &lt;a href=&quot;http://shin-kawara.seesaa.net/article/159663314.html&quot; target=&quot;_blank&quot;&gt;POIでセルの値をとるのは大変　日付編&lt;/a&gt;
 * 
 * @version 0.8.3
 * @author T.TSUCHIE
 *
 */
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">public class POICellFormatter {</span>
    
<span class="fc" id="L65">    private FormatterResolver formatterResolver = new FormatterResolver();</span>
    
    /**
     * パースしたフォーマッタをキャッシングするかどうか。
     */
<span class="fc" id="L70">    private boolean cache = true;</span>
    
    /**
     * エラーセルの値を空文字として取得するかどうか。
     */
<span class="fc" id="L75">    private boolean errorCellAsEmpty = false;</span>
    
    /**
     * 式を評価する際に失敗したときに、例外をスローするかどうか。
     */
<span class="fc" id="L80">    private boolean throwFailEvaluateFormula = false;</span>
    
    /**
     * 結合セルを考慮するかどうか。
     */
<span class="fc" id="L85">    private boolean considerMergedCell = true;</span>
    
    /**
     * セルの値を文字列として取得する
     * @param cell 取得対象のセル
     * @return フォーマットしたセルの値。 cellがnullの場合、空文字を返す。
     */
    public String formatAsString(final Cell cell) {
<span class="nc" id="L93">        return formatAsString(cell, Locale.getDefault());</span>
    }
    
    /**
     * ロケールを指定してセルの値を文字列として取得する
     * @param cell フォーマット対象のセル
     * @param locale locale フォーマットしたロケール。nullでも可能。
     *        ロケールに依存する場合、指定したロケールにより自動的に切り替わります。
     * @return フォーマットした文字列。cellがnullの場合、空文字を返す。
     */
    public String formatAsString(final Cell cell, final Locale locale) {
<span class="fc" id="L104">        return format(cell, locale).getText();</span>
    }
    
    /**
     * セルの値を取得する
     * @since 0.3
     * @param cell フォーマット対象のセル
     * @return フォーマット結果。cellがnullの場合、空セルとして値を返す。
     */
    public CellFormatResult format(final Cell cell) {
<span class="fc" id="L114">        return format(cell, Locale.getDefault());</span>
    }
    
    
    /**
     * ロケールを指定してセルの値を取得する
     * @since 0.3
     * @param cell フォーマット対象のセル
     * @param locale locale フォーマットしたロケール。nullでも可能。
     *        ロケールに依存する場合、指定したロケールにより自動的に切り替わります。
     * @return フォーマット結果。cellがnullの場合、空セルとして値を返す。
     */
    public CellFormatResult format(final Cell cell, final Locale locale) {
        
<span class="fc bfc" id="L128" title="All 2 branches covered.">        if(cell == null) {</span>
<span class="fc" id="L129">            return createBlankCellResult();</span>
        }
        
<span class="fc bfc" id="L132" title="All 2 branches covered.">        final Locale runtimeLocale = locale != null ? locale : Locale.getDefault();</span>
        
<span class="pc bpc" id="L134" title="2 of 7 branches missed.">        switch(cell.getCellType()) {</span>
            case Cell.CELL_TYPE_BLANK:
<span class="fc bfc" id="L136" title="All 2 branches covered.">                if(isConsiderMergedCell()) {</span>
                    // 結合しているセルの場合、左上のセル以外に値が設定されている場合がある。
<span class="fc" id="L138">                    return getMergedCellValue(cell, runtimeLocale);</span>
                } else {
<span class="fc" id="L140">                    return createBlankCellResult();</span>
                }
                
            case Cell.CELL_TYPE_BOOLEAN:
<span class="fc" id="L144">                return getCellValue(cell, runtimeLocale);</span>
                
            case Cell.CELL_TYPE_STRING:
<span class="fc" id="L147">                return getCellValue(cell, runtimeLocale);</span>
                
            case Cell.CELL_TYPE_NUMERIC:
<span class="fc" id="L150">                return getCellValue(cell, runtimeLocale);</span>
                
            case Cell.CELL_TYPE_FORMULA:
<span class="fc" id="L153">                return getFormulaCellValue(cell, runtimeLocale);</span>
                
            case Cell.CELL_TYPE_ERROR:
<span class="nc" id="L156">                return getErrorCellValue(cell, runtimeLocale);</span>
                
            default:
<span class="nc" id="L159">                final CellFormatResult result = new CellFormatResult();</span>
<span class="nc" id="L160">                result.setCellType(FormatCellType.Unknown);</span>
<span class="nc" id="L161">                result.setText(&quot;&quot;);</span>
<span class="nc" id="L162">                return result;</span>
        }
    }
    
    /**
     * ブランクセルの結果を作成する。
     * @since 0.7
     * @return
     */
    private CellFormatResult createBlankCellResult() {
<span class="fc" id="L172">        CellFormatResult result = new CellFormatResult();</span>
<span class="fc" id="L173">        result.setCellType(FormatCellType.Blank);</span>
<span class="fc" id="L174">        result.setText(&quot;&quot;);</span>
<span class="fc" id="L175">        return result;</span>
    }
    
    /**
     * 式が設定されているセルの値を評価する。
     * @param cell
     * @param locale
     * @return
     */
    private CellFormatResult getFormulaCellValue(final Cell cell, final Locale locale) {
        
<span class="fc" id="L186">        final int cellType = cell.getCellType();</span>
<span class="pc bpc" id="L187" title="2 of 4 branches missed.">        assert cellType == Cell.CELL_TYPE_FORMULA;</span>
        
<span class="fc" id="L189">        final Workbook workbook = cell.getSheet().getWorkbook();</span>
<span class="fc" id="L190">        final CreationHelper helper = workbook.getCreationHelper();</span>
<span class="fc" id="L191">        final FormulaEvaluator evaluator = helper.createFormulaEvaluator();</span>
        
        try {
<span class="fc" id="L194">            final CellValue value = evaluator.evaluate(cell);</span>
<span class="fc" id="L195">            final POIEvaluatedCell evaluatedCell = new POIEvaluatedCell(cell, value);</span>
            
<span class="pc bpc" id="L197" title="1 of 5 branches missed.">            switch(value.getCellType()) {</span>
                
                case Cell.CELL_TYPE_BOOLEAN:
<span class="fc" id="L200">                    return getCellValue(evaluatedCell, locale);</span>
                    
                case Cell.CELL_TYPE_STRING:
<span class="fc" id="L203">                    return getCellValue(evaluatedCell, locale);</span>
                    
                case Cell.CELL_TYPE_NUMERIC:
<span class="fc" id="L206">                    return getCellValue(evaluatedCell, locale);</span>
                    
                case Cell.CELL_TYPE_ERROR:
<span class="fc" id="L209">                    return getErrorCellValue(value.getErrorValue(), locale);</span>
                    
                default:
<span class="nc" id="L212">                    final CellFormatResult result = new CellFormatResult();</span>
<span class="nc" id="L213">                    result.setCellType(FormatCellType.Unknown);</span>
<span class="nc" id="L214">                    result.setText(&quot;&quot;);</span>
<span class="nc" id="L215">                    return result;</span>
            }
            
<span class="fc" id="L218">        } catch(Exception e) {</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">            if(isThrowFailEvaluateFormula()) {</span>
<span class="fc" id="L220">                throw new FormulaEvaluateException(cell, e);</span>
            } else {
<span class="fc" id="L222">                return getErrorCellValue(cell.getErrorCellValue(), locale);</span>
            }
        }
        
    }
    
    
    /**
     * エラーセルの値を評価する。
     * @param cell
     * @param locale
     * @return
     */
    private CellFormatResult getErrorCellValue(final Cell cell, final Locale locale) {
        
<span class="nc" id="L237">        final int cellType = cell.getCellType();</span>
<span class="nc bnc" id="L238" title="All 4 branches missed.">        assert cellType == Cell.CELL_TYPE_ERROR;</span>
        
<span class="nc" id="L240">        return getErrorCellValue(cell.getErrorCellValue(), locale);</span>
    }
    
    /**
     * エラーセルの値を評価する。
     * @since 0.8.3
     * @param errorValue エラーセルの値。
     * @param locale
     * @return
     */
    private CellFormatResult getErrorCellValue(final byte errorValue, final Locale locale) {
        
<span class="fc" id="L252">       final FormulaError error = FormulaError.forInt(errorValue);</span>
<span class="fc" id="L253">       final CellFormatResult result = new CellFormatResult();</span>
<span class="fc" id="L254">       result.setCellType(FormatCellType.Error);</span>
<span class="fc" id="L255">       result.setValue(error.getCode());</span>
       
<span class="fc bfc" id="L257" title="All 2 branches covered.">       if(isErrorCellAsEmpty()) {</span>
<span class="fc" id="L258">           result.setText(&quot;&quot;);</span>
       } else {
<span class="fc" id="L260">           result.setText(error.getString());</span>
       }
       
<span class="fc" id="L263">       return result;</span>
       
    }
    
    /**
     * 結合されているセルの値の取得。
     * &lt;p&gt;通常は左上のセルに値が設定されているが、結合されているときは左上以外のセルの値を取得する。
     * &lt;p&gt;左上以外のセルに値が設定されている場合は、CellTypeがCELL_TYPE_BLANKになるため注意が必要。
     * @param cell
     * @param locale
     * @return
     */
    private CellFormatResult getMergedCellValue(final Cell cell, final Locale locale) {
        
<span class="fc" id="L277">        final Sheet sheet = cell.getSheet();</span>
<span class="fc" id="L278">        final int size = sheet.getNumMergedRegions();</span>
        
<span class="fc bfc" id="L280" title="All 2 branches covered.">        for(int i=0; i &lt; size; i++) {</span>
<span class="fc" id="L281">            final CellRangeAddress range = sheet.getMergedRegion(i);</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">            if(!range.isInRange(cell.getRowIndex(), cell.getColumnIndex())) {</span>
<span class="fc" id="L283">                continue;</span>
            }
            
            // 非BLANKまたはnullでないセルを取得する。
<span class="fc bfc" id="L287" title="All 2 branches covered.">            for(int rowIdx=range.getFirstRow(); rowIdx &lt;= range.getLastRow(); rowIdx++) {</span>
<span class="fc" id="L288">                final Row row = sheet.getRow(rowIdx);</span>
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">                if(row == null) {</span>
<span class="nc" id="L290">                    continue;</span>
                }
                
<span class="fc bfc" id="L293" title="All 2 branches covered.">                for(int colIdx=range.getFirstColumn(); colIdx &lt;= range.getLastColumn(); colIdx++) {</span>
<span class="fc" id="L294">                    final Cell valueCell = row.getCell(colIdx);</span>
<span class="pc bpc" id="L295" title="1 of 4 branches missed.">                    if(valueCell == null || valueCell.getCellType() == Cell.CELL_TYPE_BLANK) {</span>
<span class="fc" id="L296">                        continue;</span>
                    }
                    
<span class="fc" id="L299">                    return format(valueCell, locale);</span>
                }
            }
            
        }
        
<span class="fc" id="L305">        return createBlankCellResult();</span>
    }
    
    /**
     * セルの値をフォーマットする。
     * @param cell フォーマット対象のセル
     * @param locale ロケール
     * @return フォーマットした結果
     */
    private CellFormatResult getCellValue(final Cell cell, final Locale locale) {
<span class="fc" id="L315">        return getCellValue(new POICell(cell), locale);</span>
    }
    
    /**
     * セルの値をフォーマットする。
     * @param poiCell フォーマット対象のセル
     * @param locale ロケール
     * @return フォーマットした結果
     */
    private CellFormatResult getCellValue(final POICell poiCell, final Locale locale) {
        
<span class="fc" id="L326">        final short formatIndex = poiCell.getFormatIndex();</span>
<span class="fc" id="L327">        final String formatPattern = poiCell.getFormatPattern();</span>
        
<span class="fc bfc" id="L329" title="All 2 branches covered.">        if(formatterResolver.canResolve(formatIndex)) {</span>
<span class="fc" id="L330">            final CellFormatter cellFormatter = formatterResolver.getFormatter(formatIndex);</span>
<span class="fc" id="L331">            return cellFormatter.format(poiCell, locale);</span>
            
<span class="fc bfc" id="L333" title="All 2 branches covered.">        } else if(formatterResolver.canResolve(formatPattern)) {</span>
<span class="fc" id="L334">            final CellFormatter cellFormatter = formatterResolver.getFormatter(formatPattern);</span>
<span class="fc" id="L335">            return cellFormatter.format(poiCell, locale);</span>
            
        } else {
            // キャッシュに存在しない場合
<span class="fc" id="L339">            final CellFormatter cellFormatter = formatterResolver.createFormatter(formatPattern) ;</span>
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">            if(isCache()) {</span>
<span class="fc" id="L341">                formatterResolver.registerFormatter(formatPattern, cellFormatter);</span>
            }
<span class="fc" id="L343">            return cellFormatter.format(poiCell, locale);</span>
            
        }
    }
    
    /**
     * {@link FormatterResolver}を取得する。
     * @return
     */
    public FormatterResolver getFormatterResolver() {
<span class="fc" id="L353">        return formatterResolver;</span>
    }
    
    /**
     * {@link FormatterResolver}を設定する。
     * 独自のものに入れ替える際に利用します。
     * @param formatterResolver
     */
    public void setFormatterResolver(FormatterResolver formatterResolver) {
<span class="nc" id="L362">        this.formatterResolver = formatterResolver;</span>
<span class="nc" id="L363">    }</span>
    
    /**
     * パースしたフォーマッタをキャッシュするかどうか。
     * 初期値はtrueです。
     * @return
     */
    public boolean isCache() {
<span class="fc" id="L371">        return cache;</span>
    }
    
    /**
     * パースしたフォーマッタをキャッシュするかどうか設定する。
     * @param cache true:キャッシュする。
     */
    public void setCache(boolean cache) {
<span class="fc" id="L379">        this.cache = cache;</span>
<span class="fc" id="L380">    }</span>
    
    /**
     * エラーセルの値を空文字として取得するかどうか。
     * 初期値はfalseです。
     * @since 0.4
     * @return
     */
    public boolean isErrorCellAsEmpty() {
<span class="fc" id="L389">        return errorCellAsEmpty;</span>
    }
    
    /**
     * エラーセルの値を空文字として取得するかどうか設定する。
     * @since 0.4
     * @param errorCellAsEmpty true:空文字として取得する。
     */
    public void setErrorCellAsEmpty(boolean errorCellAsEmpty) {
<span class="fc" id="L398">        this.errorCellAsEmpty = errorCellAsEmpty;</span>
<span class="fc" id="L399">    }</span>
    
    /**
     * 式を評価する際に失敗したときに、例外{@link FormulaEvaluateException}をスローするかどうか。
     * &lt;p&gt;初期値はfalseで、式の評価に失敗したときは、エラーセルとして扱われます。
     * @since 0.7
     * @return true: 例外をスローする。
     */
    public boolean isThrowFailEvaluateFormula() {
<span class="fc" id="L408">        return throwFailEvaluateFormula;</span>
    }
    
    /**
     * 式を評価する際に失敗したときに、例外{@link FormulaEvaluateException}をスローするかどうか設定する。
     * @since 0.7
     * @param throwFailEvaluateFormula true: 例外をスローする。
     */
    public void setThrowFailEvaluateFormula(boolean throwFailEvaluateFormula) {
<span class="fc" id="L417">        this.throwFailEvaluateFormula = throwFailEvaluateFormula;</span>
<span class="fc" id="L418">    }</span>
    
    /**
     * 結合されたセルを考慮するかどうか。
     * &lt;p&gt;POIの場合、結合されている領域は、左上のセル以外はブランクセルとなるため、値が設定してあるセルを操作する必要がある。
     * &lt;p&gt;初期値はtrueで、ブランクセルを結合セルと見なして処理を行います。
     * @since 0.7
     * @return true: 結合セルを考慮する。
     */
    public boolean isConsiderMergedCell() {
<span class="fc" id="L428">        return considerMergedCell;</span>
    }
    
    /**
     * 結合されたセルを考慮するかどうか。
     * &lt;p&gt;POIの場合、結合されている領域は、左上のセル以外はブランクセルとなるため、値が設定してあるセルを走査する必要がある。
     * @since 0.7
     * @param considerMergedCell true:結合セルを考慮して処理を行う。
     */
    public void setConsiderMergedCell(boolean considerMergedCell) {
<span class="fc" id="L438">        this.considerMergedCell = considerMergedCell;</span>
<span class="fc" id="L439">    }</span>
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>